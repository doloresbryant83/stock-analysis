# VBA Challenge

## Overview of Project:  
The purpose of this project was to refactor VBA code.  We expanded on an initial data set that included a smaller subset of stock (used in the homework assignment).  The intent was to refactor the code to make it more efficient to analyze thousands of stocks â€“ by taking fewer steps, using less memory, and improving the logic of the code to make it easier for other users to read.

## Results:  
Between 2017 and 2018, there was a marked decrease with all the stocks (with the exception of RUN).  RUN actually increased in its return between 2017 and 2018.  Also, ENPH did follow the trend of decreasing in its return, but did generate a positive return in 2018. Further, the execution times between the original script and refactored script showed a decrease in run time between the original code and the refactored code.  This met the intent of making the code more efficient.  


![VBA_Challenge_2017](https://github.com/doloresbryant83/stock-analysis/blob/main/VBA_Challenge_2017.png)

![VBA_Challenge_2018](https://github.com/doloresbryant83/stock-analysis/blob/main/VBA_Challenge_2018.png)

![VBA_2017_Runtime](https://github.com/doloresbryant83/stock-analysis/blob/main/VBA_2017_Runtime.png)

![VBA_2018_Runtime](https://github.com/doloresbryant83/stock-analysis/blob/main/VBA_2018_Runtime.png)

## Summary: 
The advantage of refactoring code is starting with a baseline of code and not having to start completely from scratch.  It allows for the initial analysis of code and the further improvement and the ability to debug the code, with the goal to make the programming faster.  Yet there are also disadvantages to refactoring code.  If the original code is not efficiently marked with a clear description of the code, it could be difficult to work with and more time consuming than starting a project from scratch.  Yet, the pros of applying the refactoring of the original VBA script, was it allowed me to readily recall what we did in the homework assignments.  I have heard repeatedly that good programmers are often lazy programmers (so we are off to a good start). 
